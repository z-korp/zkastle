/* Autogenerated file. Do not edit manually. */

import { DojoProvider } from "@dojoengine/core";
import { Config } from "../../../dojo.config.ts";
import { Account, UniversalDetails, shortString } from "starknet";

export interface Signer {
  account: Account;
}

export interface Initialize extends Signer {
  world: string;
}

export interface Create extends Signer {
  name: string;
}

export interface Rename extends Signer {
  name: string;
}

export interface Select extends Signer {
  card_id: number;
}

export interface Enable extends Signer {
  achievement_id: number;
  enable: boolean;
}

export interface Start extends Signer {
  x: bigint;
  y: bigint;
  c: bigint;
  s: bigint;
  sqrt_ratio_hint: bigint;
  seed: bigint;
  beta: bigint;
}

export interface Play extends Signer {
  action: number;
  choice: boolean;
  resources: bigint;
}

export interface Discard extends Signer {
  slot_index: number;
}

export type Surrender = Signer;

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export const getContractByName = (manifest: any, name: string) => {
  const contract = manifest.contracts.find((contract: any) =>
    contract.name.includes("::" + name),
  );
  if (contract) {
    return contract.address;
  } else {
    return "";
  }
};

export async function setupWorld(provider: DojoProvider, config: Config) {
  const details: UniversalDetails | undefined = undefined; // { maxFee: 1e15 };

  function actions() {
    const contract_name = "actions";
    const contract = config.manifest.contracts.find((c: any) =>
      c.name.includes(contract_name),
    );
    if (!contract) {
      throw new Error(`Contract ${contract_name} not found in manifest`);
    }

    const initialize = async ({ account, world }: Initialize) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "initialize",
            calldata: [world],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing initialize:", error);
        throw error;
      }
    };

    const create = async ({ account, name }: Create) => {
      try {
        const encoded_name = shortString.encodeShortString(name);
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "create",
            calldata: [provider.getWorldAddress(), encoded_name],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing create:", error);
        throw error;
      }
    };

    const rename = async ({ account, name }: Rename) => {
      try {
        const encoded_name = shortString.encodeShortString(name);
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "rename",
            calldata: [provider.getWorldAddress(), encoded_name],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing rename:", error);
        throw error;
      }
    };

    const select = async ({ account, card_id }: Select) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "select",
            calldata: [provider.getWorldAddress(), card_id],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing select:", error);
        throw error;
      }
    };

    const enable = async ({ account, achievement_id, enable }: Enable) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "enable",
            calldata: [provider.getWorldAddress(), achievement_id, enable],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing enable:", error);
        throw error;
      }
    };

    const start = async ({
      account,
      x,
      y,
      c,
      s,
      sqrt_ratio_hint,
      seed,
      beta,
    }: Start) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "start",
            calldata: [
              provider.getWorldAddress(),
              x,
              y,
              c,
              s,
              sqrt_ratio_hint,
              seed,
              beta,
            ],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing start:", error);
        throw error;
      }
    };

    const play = async ({ account, action, choice, resources }: Play) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "play",
            calldata: [
              provider.getWorldAddress(),
              action,
              choice ? 1 : 0,
              resources,
            ],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing play:", error);
        throw error;
      }
    };

    const discard = async ({ account, slot_index }: Discard) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [provider.getWorldAddress(), slot_index],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    const surrender = async ({ account }: Surrender) => {
      try {
        return await provider.execute(
          account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [provider.getWorldAddress()],
          },
          details,
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    return {
      address: contract.address,
      initialize,
      create,
      rename,
      select,
      enable,
      start,
      play,
      discard,
      surrender,
    };
  }

  return {
    actions: actions(),
  };
}
